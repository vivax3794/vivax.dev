{
  "resolvedId": "/home/vivax/coding/vivax.dev/node_modules/quasar/src/components/date/QDate.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { h, ref, computed, watch, Transition, nextTick, getCurrentInstance } from 'vue'\n\nimport QBtn from '../btn/QBtn.js'\n\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js'\nimport useCache from '../../composables/private/use-cache.js'\nimport { useFormProps, useFormAttrs, useFormInject } from '../../composables/private/use-form.js'\nimport useDatetime, { useDatetimeProps, useDatetimeEmits, getDayHash } from './use-datetime.js'\n\nimport { createComponent } from '../../utils/private/create.js'\nimport { hSlot } from '../../utils/private/render.js'\nimport { formatDate, __splitDate, getDateDiff } from '../../utils/date.js'\nimport { pad } from '../../utils/format.js'\nimport { jalaaliMonthLength, toGregorian } from '../../utils/private/date-persian.js'\nimport { isObject } from '../../utils/is.js'\n\nconst yearsInterval = 20\nconst views = [ 'Calendar', 'Years', 'Months' ]\nconst viewIsValid = v => views.includes(v)\nconst yearMonthValidator = v => /^-?[\\d]+\\/[0-1]\\d$/.test(v)\nconst lineStr = ' \\u2014 '\n\nfunction getMonthHash (date) {\n  return date.year + '/' + pad(date.month)\n}\n\nexport default createComponent({\n  name: 'QDate',\n\n  props: {\n    ...useDatetimeProps,\n    ...useFormProps,\n    ...useDarkProps,\n\n    multiple: Boolean,\n    range: Boolean,\n\n    title: String,\n    subtitle: String,\n\n    mask: {\n      // this mask is forced\n      // when using persian calendar\n      default: 'YYYY/MM/DD'\n    },\n\n    defaultYearMonth: {\n      type: String,\n      validator: yearMonthValidator\n    },\n\n    yearsInMonthView: Boolean,\n\n    events: [ Array, Function ],\n    eventColor: [ String, Function ],\n\n    emitImmediately: Boolean,\n\n    options: [ Array, Function ],\n\n    navigationMinYearMonth: {\n      type: String,\n      validator: yearMonthValidator\n    },\n\n    navigationMaxYearMonth: {\n      type: String,\n      validator: yearMonthValidator\n    },\n\n    noUnset: Boolean,\n\n    firstDayOfWeek: [ String, Number ],\n    todayBtn: Boolean,\n    minimal: Boolean,\n    defaultView: {\n      type: String,\n      default: 'Calendar',\n      validator: viewIsValid\n    }\n  },\n\n  emits: [\n    ...useDatetimeEmits,\n    'rangeStart', 'rangeEnd', 'navigation'\n  ],\n\n  setup (props, { slots, emit }) {\n    const { proxy } = getCurrentInstance()\n    const { $q } = proxy\n\n    const isDark = useDark(props, $q)\n    const { getCache } = useCache()\n    const { tabindex, headerClass, getLocale, getCurrentDate } = useDatetime(props, $q)\n\n    let lastEmitValue\n\n    const formAttrs = useFormAttrs(props)\n    const injectFormInput = useFormInject(formAttrs)\n\n    const blurTargetRef = ref(null)\n    const innerMask = ref(getMask())\n    const innerLocale = ref(getLocale())\n\n    const mask = computed(() => getMask())\n    const locale = computed(() => getLocale())\n\n    const today = computed(() => getCurrentDate())\n\n    // model of current calendar view:\n    const viewModel = ref(getViewModel(innerMask.value, innerLocale.value))\n\n    const view = ref(props.defaultView)\n\n    const direction = $q.lang.rtl === true ? 'right' : 'left'\n    const monthDirection = ref(direction.value)\n    const yearDirection = ref(direction.value)\n\n    const year = viewModel.value.year\n    const startYear = ref(year - (year % yearsInterval) - (year < 0 ? yearsInterval : 0))\n    const editRange = ref(null)\n\n    const classes = computed(() => {\n      const type = props.landscape === true ? 'landscape' : 'portrait'\n      return `q-date q-date--${ type } q-date--${ type }-${ props.minimal === true ? 'minimal' : 'standard' }`\n        + (isDark.value === true ? ' q-date--dark q-dark' : '')\n        + (props.bordered === true ? ' q-date--bordered' : '')\n        + (props.square === true ? ' q-date--square no-border-radius' : '')\n        + (props.flat === true ? ' q-date--flat no-shadow' : '')\n        + (props.disable === true ? ' disabled' : (props.readonly === true ? ' q-date--readonly' : ''))\n    })\n\n    const computedColor = computed(() => {\n      return props.color || 'primary'\n    })\n\n    const computedTextColor = computed(() => {\n      return props.textColor || 'white'\n    })\n\n    const isImmediate = computed(() =>\n      props.emitImmediately === true\n      && props.multiple !== true\n      && props.range !== true\n    )\n\n    const normalizedModel = computed(() => (\n      Array.isArray(props.modelValue) === true\n        ? props.modelValue\n        : (props.modelValue !== null && props.modelValue !== void 0 ? [ props.modelValue ] : [])\n    ))\n\n    const daysModel = computed(() =>\n      normalizedModel.value\n        .filter(date => typeof date === 'string')\n        .map(date => decodeString(date, innerMask.value, innerLocale.value))\n        .filter(date =>\n          date.dateHash !== null\n          && date.day !== null\n          && date.month !== null\n          && date.year !== null\n        )\n    )\n\n    const rangeModel = computed(() => {\n      const fn = date => decodeString(date, innerMask.value, innerLocale.value)\n      return normalizedModel.value\n        .filter(date => isObject(date) === true && date.from !== void 0 && date.to !== void 0)\n        .map(range => ({ from: fn(range.from), to: fn(range.to) }))\n        .filter(range => range.from.dateHash !== null && range.to.dateHash !== null && range.from.dateHash < range.to.dateHash)\n    })\n\n    const getNativeDateFn = computed(() => (\n      props.calendar !== 'persian'\n        ? model => new Date(model.year, model.month - 1, model.day)\n        : model => {\n          const gDate = toGregorian(model.year, model.month, model.day)\n          return new Date(gDate.gy, gDate.gm - 1, gDate.gd)\n        }\n    ))\n\n    const encodeObjectFn = computed(() => (\n      props.calendar === 'persian'\n        ? getDayHash\n        : (date, mask, locale) => formatDate(\n            new Date(\n              date.year,\n              date.month - 1,\n              date.day,\n              date.hour,\n              date.minute,\n              date.second,\n              date.millisecond\n            ),\n            mask === void 0 ? innerMask.value : mask,\n            locale === void 0 ? innerLocale.value : locale,\n            date.year,\n            date.timezoneOffset\n          )\n    ))\n\n    const daysInModel = computed(() =>\n      daysModel.value.length + rangeModel.value.reduce(\n        (acc, range) => acc + 1 + getDateDiff(\n          getNativeDateFn.value(range.to),\n          getNativeDateFn.value(range.from)\n        ),\n        0\n      )\n    )\n\n    const headerTitle = computed(() => {\n      if (props.title !== void 0 && props.title !== null && props.title.length !== 0) {\n        return props.title\n      }\n\n      if (editRange.value !== null) {\n        const model = editRange.value.init\n        const date = getNativeDateFn.value(model)\n\n        return innerLocale.value.daysShort[ date.getDay() ] + ', '\n          + innerLocale.value.monthsShort[ model.month - 1 ] + ' '\n          + model.day + lineStr + '?'\n      }\n\n      if (daysInModel.value === 0) {\n        return lineStr\n      }\n\n      if (daysInModel.value > 1) {\n        return `${ daysInModel.value } ${ innerLocale.value.pluralDay }`\n      }\n\n      const model = daysModel.value[ 0 ]\n      const date = getNativeDateFn.value(model)\n\n      if (isNaN(date.valueOf()) === true) {\n        return lineStr\n      }\n\n      if (innerLocale.value.headerTitle !== void 0) {\n        return innerLocale.value.headerTitle(date, model)\n      }\n\n      return innerLocale.value.daysShort[ date.getDay() ] + ', '\n        + innerLocale.value.monthsShort[ model.month - 1 ] + ' '\n        + model.day\n    })\n\n    const minSelectedModel = computed(() => {\n      const model = daysModel.value.concat(rangeModel.value.map(range => range.from))\n        .sort((a, b) => a.year - b.year || a.month - b.month)\n\n      return model[ 0 ]\n    })\n\n    const maxSelectedModel = computed(() => {\n      const model = daysModel.value.concat(rangeModel.value.map(range => range.to))\n        .sort((a, b) => b.year - a.year || b.month - a.month)\n\n      return model[ 0 ]\n    })\n\n    const headerSubtitle = computed(() => {\n      if (props.subtitle !== void 0 && props.subtitle !== null && props.subtitle.length !== 0) {\n        return props.subtitle\n      }\n\n      if (daysInModel.value === 0) {\n        return lineStr\n      }\n\n      if (daysInModel.value > 1) {\n        const from = minSelectedModel.value\n        const to = maxSelectedModel.value\n        const month = innerLocale.value.monthsShort\n\n        return month[ from.month - 1 ] + (\n          from.year !== to.year\n            ? ' ' + from.year + lineStr + month[ to.month - 1 ] + ' '\n            : (\n                from.month !== to.month\n                  ? lineStr + month[ to.month - 1 ]\n                  : ''\n              )\n        ) + ' ' + to.year\n      }\n\n      return daysModel.value[ 0 ].year\n    })\n\n    const dateArrow = computed(() => {\n      const val = [ $q.iconSet.datetime.arrowLeft, $q.iconSet.datetime.arrowRight ]\n      return $q.lang.rtl === true ? val.reverse() : val\n    })\n\n    const computedFirstDayOfWeek = computed(() => (\n      props.firstDayOfWeek !== void 0\n        ? Number(props.firstDayOfWeek)\n        : innerLocale.value.firstDayOfWeek\n    ))\n\n    const daysOfWeek = computed(() => {\n      const\n        days = innerLocale.value.daysShort,\n        first = computedFirstDayOfWeek.value\n\n      return first > 0\n        ? days.slice(first, 7).concat(days.slice(0, first))\n        : days\n    })\n\n    const daysInMonth = computed(() => {\n      const date = viewModel.value\n      return props.calendar !== 'persian'\n        ? (new Date(date.year, date.month, 0)).getDate()\n        : jalaaliMonthLength(date.year, date.month)\n    })\n\n    const evtColor = computed(() => (\n      typeof props.eventColor === 'function'\n        ? props.eventColor\n        : () => props.eventColor\n    ))\n\n    const minNav = computed(() => {\n      if (props.navigationMinYearMonth === void 0) {\n        return null\n      }\n\n      const data = props.navigationMinYearMonth.split('/')\n      return { year: parseInt(data[ 0 ], 10), month: parseInt(data[ 1 ], 10) }\n    })\n\n    const maxNav = computed(() => {\n      if (props.navigationMaxYearMonth === void 0) {\n        return null\n      }\n\n      const data = props.navigationMaxYearMonth.split('/')\n      return { year: parseInt(data[ 0 ], 10), month: parseInt(data[ 1 ], 10) }\n    })\n\n    const navBoundaries = computed(() => {\n      const data = {\n        month: { prev: true, next: true },\n        year: { prev: true, next: true }\n      }\n\n      if (minNav.value !== null && minNav.value.year >= viewModel.value.year) {\n        data.year.prev = false\n        if (minNav.value.year === viewModel.value.year && minNav.value.month >= viewModel.value.month) {\n          data.month.prev = false\n        }\n      }\n\n      if (maxNav.value !== null && maxNav.value.year <= viewModel.value.year) {\n        data.year.next = false\n        if (maxNav.value.year === viewModel.value.year && maxNav.value.month <= viewModel.value.month) {\n          data.month.next = false\n        }\n      }\n\n      return data\n    })\n\n    const daysMap = computed(() => {\n      const map = {}\n\n      daysModel.value.forEach(entry => {\n        const hash = getMonthHash(entry)\n\n        if (map[ hash ] === void 0) {\n          map[ hash ] = []\n        }\n\n        map[ hash ].push(entry.day)\n      })\n\n      return map\n    })\n\n    const rangeMap = computed(() => {\n      const map = {}\n\n      rangeModel.value.forEach(entry => {\n        const hashFrom = getMonthHash(entry.from)\n        const hashTo = getMonthHash(entry.to)\n\n        if (map[ hashFrom ] === void 0) {\n          map[ hashFrom ] = []\n        }\n\n        map[ hashFrom ].push({\n          from: entry.from.day,\n          to: hashFrom === hashTo ? entry.to.day : void 0,\n          range: entry\n        })\n\n        if (hashFrom < hashTo) {\n          let hash\n          const { year, month } = entry.from\n          const cur = month < 12\n            ? { year, month: month + 1 }\n            : { year: year + 1, month: 1 }\n\n          while ((hash = getMonthHash(cur)) <= hashTo) {\n            if (map[ hash ] === void 0) {\n              map[ hash ] = []\n            }\n\n            map[ hash ].push({\n              from: void 0,\n              to: hash === hashTo ? entry.to.day : void 0,\n              range: entry\n            })\n\n            cur.month++\n            if (cur.month > 12) {\n              cur.year++\n              cur.month = 1\n            }\n          }\n        }\n      })\n\n      return map\n    })\n\n    const rangeView = computed(() => {\n      if (editRange.value === null) {\n        return\n      }\n\n      const { init, initHash, final, finalHash } = editRange.value\n\n      const [ from, to ] = initHash <= finalHash\n        ? [ init, final ]\n        : [ final, init ]\n\n      const fromHash = getMonthHash(from)\n      const toHash = getMonthHash(to)\n\n      if (fromHash !== viewMonthHash.value && toHash !== viewMonthHash.value) {\n        return\n      }\n\n      const view = {}\n\n      if (fromHash === viewMonthHash.value) {\n        view.from = from.day\n        view.includeFrom = true\n      }\n      else {\n        view.from = 1\n      }\n\n      if (toHash === viewMonthHash.value) {\n        view.to = to.day\n        view.includeTo = true\n      }\n      else {\n        view.to = daysInMonth.value\n      }\n\n      return view\n    })\n\n    const viewMonthHash = computed(() => getMonthHash(viewModel.value))\n\n    const selectionDaysMap = computed(() => {\n      const map = {}\n\n      if (props.options === void 0) {\n        for (let i = 1; i <= daysInMonth.value; i++) {\n          map[ i ] = true\n        }\n\n        return map\n      }\n\n      const fn = typeof props.options === 'function'\n        ? props.options\n        : date => props.options.includes(date)\n\n      for (let i = 1; i <= daysInMonth.value; i++) {\n        const dayHash = viewMonthHash.value + '/' + pad(i)\n        map[ i ] = fn(dayHash)\n      }\n\n      return map\n    })\n\n    const eventDaysMap = computed(() => {\n      const map = {}\n\n      if (props.events === void 0) {\n        for (let i = 1; i <= daysInMonth.value; i++) {\n          map[ i ] = false\n        }\n      }\n      else {\n        const fn = typeof props.events === 'function'\n          ? props.events\n          : date => props.events.includes(date)\n\n        for (let i = 1; i <= daysInMonth.value; i++) {\n          const dayHash = viewMonthHash.value + '/' + pad(i)\n          map[ i ] = fn(dayHash) === true && evtColor.value(dayHash)\n        }\n      }\n\n      return map\n    })\n\n    const viewDays = computed(() => {\n      let date, endDay\n      const { year, month } = viewModel.value\n\n      if (props.calendar !== 'persian') {\n        date = new Date(year, month - 1, 1)\n        endDay = (new Date(year, month - 1, 0)).getDate()\n      }\n      else {\n        const gDate = toGregorian(year, month, 1)\n        date = new Date(gDate.gy, gDate.gm - 1, gDate.gd)\n        let prevJM = month - 1\n        let prevJY = year\n        if (prevJM === 0) {\n          prevJM = 12\n          prevJY--\n        }\n        endDay = jalaaliMonthLength(prevJY, prevJM)\n      }\n\n      return {\n        days: date.getDay() - computedFirstDayOfWeek.value - 1,\n        endDay\n      }\n    })\n\n    const days = computed(() => {\n      const res = []\n      const { days, endDay } = viewDays.value\n\n      const len = days < 0 ? days + 7 : days\n      if (len < 6) {\n        for (let i = endDay - len; i <= endDay; i++) {\n          res.push({ i, fill: true })\n        }\n      }\n\n      const index = res.length\n\n      for (let i = 1; i <= daysInMonth.value; i++) {\n        const day = { i, event: eventDaysMap.value[ i ], classes: [] }\n\n        if (selectionDaysMap.value[ i ] === true) {\n          day.in = true\n          day.flat = true\n        }\n\n        res.push(day)\n      }\n\n      // if current view has days in model\n      if (daysMap.value[ viewMonthHash.value ] !== void 0) {\n        daysMap.value[ viewMonthHash.value ].forEach(day => {\n          const i = index + day - 1\n          Object.assign(res[ i ], {\n            selected: true,\n            unelevated: true,\n            flat: false,\n            color: computedColor.value,\n            textColor: computedTextColor.value\n          })\n        })\n      }\n\n      // if current view has ranges in model\n      if (rangeMap.value[ viewMonthHash.value ] !== void 0) {\n        rangeMap.value[ viewMonthHash.value ].forEach(entry => {\n          if (entry.from !== void 0) {\n            const from = index + entry.from - 1\n            const to = index + (entry.to || daysInMonth.value) - 1\n\n            for (let day = from; day <= to; day++) {\n              Object.assign(res[ day ], {\n                range: entry.range,\n                unelevated: true,\n                color: computedColor.value,\n                textColor: computedTextColor.value\n              })\n            }\n\n            Object.assign(res[ from ], {\n              rangeFrom: true,\n              flat: false\n            })\n\n            entry.to !== void 0 && Object.assign(res[ to ], {\n              rangeTo: true,\n              flat: false\n            })\n          }\n          else if (entry.to !== void 0) {\n            const to = index + entry.to - 1\n\n            for (let day = index; day <= to; day++) {\n              Object.assign(res[ day ], {\n                range: entry.range,\n                unelevated: true,\n                color: computedColor.value,\n                textColor: computedTextColor.value\n              })\n            }\n\n            Object.assign(res[ to ], {\n              flat: false,\n              rangeTo: true\n            })\n          }\n          else {\n            const to = index + daysInMonth.value - 1\n            for (let day = index; day <= to; day++) {\n              Object.assign(res[ day ], {\n                range: entry.range,\n                unelevated: true,\n                color: computedColor.value,\n                textColor: computedTextColor.value\n              })\n            }\n          }\n        })\n      }\n\n      if (rangeView.value !== void 0) {\n        const from = index + rangeView.value.from - 1\n        const to = index + rangeView.value.to - 1\n\n        for (let day = from; day <= to; day++) {\n          res[ day ].color = computedColor.value\n          res[ day ].editRange = true\n        }\n\n        if (rangeView.value.includeFrom === true) {\n          res[ from ].editRangeFrom = true\n        }\n        if (rangeView.value.includeTo === true) {\n          res[ to ].editRangeTo = true\n        }\n      }\n\n      if (viewModel.value.year === today.value.year && viewModel.value.month === today.value.month) {\n        res[ index + today.value.day - 1 ].today = true\n      }\n\n      const left = res.length % 7\n      if (left > 0) {\n        const afterDays = 7 - left\n        for (let i = 1; i <= afterDays; i++) {\n          res.push({ i, fill: true })\n        }\n      }\n\n      res.forEach(day => {\n        let cls = 'q-date__calendar-item '\n\n        if (day.fill === true) {\n          cls += 'q-date__calendar-item--fill'\n        }\n        else {\n          cls += `q-date__calendar-item--${ day.in === true ? 'in' : 'out' }`\n\n          if (day.range !== void 0) {\n            cls += ` q-date__range${ day.rangeTo === true ? '-to' : (day.rangeFrom === true ? '-from' : '') }`\n          }\n\n          if (day.editRange === true) {\n            cls += ` q-date__edit-range${ day.editRangeFrom === true ? '-from' : '' }${ day.editRangeTo === true ? '-to' : '' }`\n          }\n\n          if (day.range !== void 0 || day.editRange === true) {\n            cls += ` text-${ day.color }`\n          }\n        }\n\n        day.classes = cls\n      })\n\n      return res\n    })\n\n    const attributes = computed(() => (\n      props.disable === true\n        ? { 'aria-disabled': 'true' }\n        : {}\n    ))\n\n    watch(() => props.modelValue, v => {\n      if (lastEmitValue === v) {\n        lastEmitValue = 0\n      }\n      else {\n        const model = getViewModel(innerMask.value, innerLocale.value)\n        updateViewModel(model.year, model.month, model)\n      }\n    })\n\n    watch(view, () => {\n      if (blurTargetRef.value !== null && proxy.$el.contains(document.activeElement) === true) {\n        blurTargetRef.value.focus()\n      }\n    })\n\n    watch(() => viewModel.value.year + '|' + viewModel.value.month, () => {\n      emit('navigation', { year: viewModel.value.year, month: viewModel.value.month })\n    })\n\n    watch(mask, val => {\n      updateValue(val, innerLocale.value, 'mask')\n      innerMask.value = val\n    })\n\n    watch(locale, val => {\n      updateValue(innerMask.value, val, 'locale')\n      innerLocale.value = val\n    })\n\n    function setToday () {\n      const { year, month, day } = today.value\n\n      const date = {\n        // contains more props than needed (hour, minute, second, millisecond)\n        // but those aren't used in the processing of this \"date\" variable\n        ...viewModel.value,\n\n        // overwriting with today's date\n        year,\n        month,\n        day\n      }\n\n      const monthMap = daysMap.value[ getMonthHash(date) ]\n\n      if (monthMap === void 0 || monthMap.includes(date.day) === false) {\n        addToModel(date)\n      }\n\n      setCalendarTo(date.year, date.month)\n    }\n\n    function setView (viewMode) {\n      if (viewIsValid(viewMode) === true) {\n        view.value = viewMode\n      }\n    }\n\n    function offsetCalendar (type, descending) {\n      if ([ 'month', 'year' ].includes(type)) {\n        const fn = type === 'month' ? goToMonth : goToYear\n        fn(descending === true ? -1 : 1)\n      }\n    }\n\n    function setCalendarTo (year, month) {\n      view.value = 'Calendar'\n      updateViewModel(year, month)\n    }\n\n    function setEditingRange (from, to) {\n      if (props.range === false || !from) {\n        editRange.value = null\n        return\n      }\n\n      const init = Object.assign({ ...viewModel.value }, from)\n      const final = to !== void 0\n        ? Object.assign({ ...viewModel.value }, to)\n        : init\n\n      editRange.value = {\n        init,\n        initHash: getDayHash(init),\n        final,\n        finalHash: getDayHash(final)\n      }\n\n      setCalendarTo(init.year, init.month)\n    }\n\n    function getMask () {\n      return props.calendar === 'persian' ? 'YYYY/MM/DD' : props.mask\n    }\n\n    function decodeString (date, mask, locale) {\n      return __splitDate(\n        date,\n        mask,\n        locale,\n        props.calendar,\n        {\n          hour: 0,\n          minute: 0,\n          second: 0,\n          millisecond: 0\n        }\n      )\n    }\n\n    function getViewModel (mask, locale) {\n      const model = Array.isArray(props.modelValue) === true\n        ? props.modelValue\n        : (props.modelValue ? [ props.modelValue ] : [])\n\n      if (model.length === 0) {\n        return getDefaultViewModel()\n      }\n\n      const target = model[ model.length - 1 ]\n      const decoded = decodeString(\n        target.from !== void 0 ? target.from : target,\n        mask,\n        locale\n      )\n\n      return decoded.dateHash === null\n        ? getDefaultViewModel()\n        : decoded\n    }\n\n    function getDefaultViewModel () {\n      let year, month\n\n      if (props.defaultYearMonth !== void 0) {\n        const d = props.defaultYearMonth.split('/')\n        year = parseInt(d[ 0 ], 10)\n        month = parseInt(d[ 1 ], 10)\n      }\n      else {\n        // may come from data() where computed\n        // props are not yet available\n        const d = today.value !== void 0\n          ? today.value\n          : getCurrentDate()\n\n        year = d.year\n        month = d.month\n      }\n\n      return {\n        year,\n        month,\n        day: 1,\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0,\n        dateHash: year + '/' + pad(month) + '/01'\n      }\n    }\n\n    function goToMonth (offset) {\n      let year = viewModel.value.year\n      let month = Number(viewModel.value.month) + offset\n\n      if (month === 13) {\n        month = 1\n        year++\n      }\n      else if (month === 0) {\n        month = 12\n        year--\n      }\n\n      updateViewModel(year, month)\n      isImmediate.value === true && emitImmediately('month')\n    }\n\n    function goToYear (offset) {\n      const year = Number(viewModel.value.year) + offset\n      updateViewModel(year, viewModel.value.month)\n      isImmediate.value === true && emitImmediately('year')\n    }\n\n    function setYear (year) {\n      updateViewModel(year, viewModel.value.month)\n      view.value = props.defaultView === 'Years' ? 'Months' : 'Calendar'\n      isImmediate.value === true && emitImmediately('year')\n    }\n\n    function setMonth (month) {\n      updateViewModel(viewModel.value.year, month)\n      view.value = 'Calendar'\n      isImmediate.value === true && emitImmediately('month')\n    }\n\n    function toggleDate (date, monthHash) {\n      const month = daysMap.value[ monthHash ]\n      const fn = month !== void 0 && month.includes(date.day) === true\n        ? removeFromModel\n        : addToModel\n\n      fn(date)\n    }\n\n    function getShortDate (date) {\n      return { year: date.year, month: date.month, day: date.day }\n    }\n\n    function updateViewModel (year, month, time) {\n      if (minNav.value !== null && year <= minNav.value.year) {\n        if (month < minNav.value.month || year < minNav.value.year) {\n          month = minNav.value.month\n        }\n        year = minNav.value.year\n      }\n\n      if (maxNav.value !== null && year >= maxNav.value.year) {\n        if (month > maxNav.value.month || year > maxNav.value.year) {\n          month = maxNav.value.month\n        }\n        year = maxNav.value.year\n      }\n\n      if (time !== void 0) {\n        const { hour, minute, second, millisecond, timezoneOffset, timeHash } = time\n        Object.assign(viewModel.value, { hour, minute, second, millisecond, timezoneOffset, timeHash })\n      }\n\n      const newHash = year + '/' + pad(month) + '/01'\n\n      if (newHash !== viewModel.value.dateHash) {\n        monthDirection.value = (viewModel.value.dateHash < newHash) === ($q.lang.rtl !== true) ? 'left' : 'right'\n        if (year !== viewModel.value.year) {\n          yearDirection.value = monthDirection.value\n        }\n\n        nextTick(() => {\n          startYear.value = year - year % yearsInterval - (year < 0 ? yearsInterval : 0)\n          Object.assign(viewModel.value, {\n            year,\n            month,\n            day: 1,\n            dateHash: newHash\n          })\n        })\n      }\n    }\n\n    function emitValue (val, action, date) {\n      const value = val !== null && val.length === 1 && props.multiple === false\n        ? val[ 0 ]\n        : val\n\n      lastEmitValue = value\n\n      const { reason, details } = getEmitParams(action, date)\n      emit('update:modelValue', value, reason, details)\n    }\n\n    function emitImmediately (reason) {\n      const date = daysModel.value[ 0 ] !== void 0 && daysModel.value[ 0 ].dateHash !== null\n        ? { ...daysModel.value[ 0 ] }\n        : { ...viewModel.value } // inherit day, hours, minutes, milliseconds...\n\n      // nextTick required because of animation delay in viewModel\n      nextTick(() => {\n        date.year = viewModel.value.year\n        date.month = viewModel.value.month\n\n        const maxDay = props.calendar !== 'persian'\n          ? (new Date(date.year, date.month, 0)).getDate()\n          : jalaaliMonthLength(date.year, date.month)\n\n        date.day = Math.min(Math.max(1, date.day), maxDay)\n\n        const value = encodeEntry(date)\n        lastEmitValue = value\n\n        const { details } = getEmitParams('', date)\n        emit('update:modelValue', value, reason, details)\n      })\n    }\n\n    function getEmitParams (action, date) {\n      return date.from !== void 0\n        ? {\n            reason: `${ action }-range`,\n            details: {\n              ...getShortDate(date.target),\n              from: getShortDate(date.from),\n              to: getShortDate(date.to)\n            }\n          }\n        : {\n            reason: `${ action }-day`,\n            details: getShortDate(date)\n          }\n    }\n\n    function encodeEntry (date, mask, locale) {\n      return date.from !== void 0\n        ? { from: encodeObjectFn.value(date.from, mask, locale), to: encodeObjectFn.value(date.to, mask, locale) }\n        : encodeObjectFn.value(date, mask, locale)\n    }\n\n    function addToModel (date) {\n      let value\n\n      if (props.multiple === true) {\n        if (date.from !== void 0) {\n          // we also need to filter out intersections\n\n          const fromHash = getDayHash(date.from)\n          const toHash = getDayHash(date.to)\n\n          const days = daysModel.value\n            .filter(day => day.dateHash < fromHash || day.dateHash > toHash)\n\n          const ranges = rangeModel.value\n            .filter(({ from, to }) => to.dateHash < fromHash || from.dateHash > toHash)\n\n          value = days.concat(ranges).concat(date).map(entry => encodeEntry(entry))\n        }\n        else {\n          const model = normalizedModel.value.slice()\n          model.push(encodeEntry(date))\n          value = model\n        }\n      }\n      else {\n        value = encodeEntry(date)\n      }\n\n      emitValue(value, 'add', date)\n    }\n\n    function removeFromModel (date) {\n      if (props.noUnset === true) {\n        return\n      }\n\n      let model = null\n\n      if (props.multiple === true && Array.isArray(props.modelValue) === true) {\n        const val = encodeEntry(date)\n\n        if (date.from !== void 0) {\n          model = props.modelValue.filter(\n            date => (\n              date.from !== void 0\n                ? (date.from !== val.from && date.to !== val.to)\n                : true\n            )\n          )\n        }\n        else {\n          model = props.modelValue.filter(date => date !== val)\n        }\n\n        if (model.length === 0) {\n          model = null\n        }\n      }\n\n      emitValue(model, 'remove', date)\n    }\n\n    function updateValue (mask, locale, reason) {\n      const model = daysModel.value\n        .concat(rangeModel.value)\n        .map(entry => encodeEntry(entry, mask, locale))\n        .filter(entry => {\n          return entry.from !== void 0\n            ? entry.from.dateHash !== null && entry.to.dateHash !== null\n            : entry.dateHash !== null\n        })\n\n      emit('update:modelValue', (props.multiple === true ? model : model[ 0 ]) || null, reason)\n    }\n\n    function getHeader () {\n      if (props.minimal === true) { return }\n\n      return h('div', {\n        class: 'q-date__header ' + headerClass.value\n      }, [\n        h('div', {\n          class: 'relative-position'\n        }, [\n          h(Transition, {\n            name: 'q-transition--fade'\n          }, () => h('div', {\n            key: 'h-yr-' + headerSubtitle.value,\n            class: 'q-date__header-subtitle q-date__header-link '\n              + (view.value === 'Years' ? 'q-date__header-link--active' : 'cursor-pointer'),\n            tabindex: tabindex.value,\n            ...getCache('vY', {\n              onClick () { view.value = 'Years' },\n              onKeyup (e) { e.keyCode === 13 && (view.value = 'Years') }\n            })\n          }, [ headerSubtitle.value ]))\n        ]),\n\n        h('div', {\n          class: 'q-date__header-title relative-position flex no-wrap'\n        }, [\n          h('div', {\n            class: 'relative-position col'\n          }, [\n            h(Transition, {\n              name: 'q-transition--fade'\n            }, () => h('div', {\n              key: 'h-sub' + headerTitle.value,\n              class: 'q-date__header-title-label q-date__header-link '\n                + (view.value === 'Calendar' ? 'q-date__header-link--active' : 'cursor-pointer'),\n              tabindex: tabindex.value,\n              ...getCache('vC', {\n                onClick () { view.value = 'Calendar' },\n                onKeyup (e) { e.keyCode === 13 && (view.value = 'Calendar') }\n              })\n            }, [ headerTitle.value ]))\n          ]),\n\n          props.todayBtn === true ? h(QBtn, {\n            class: 'q-date__header-today self-start',\n            icon: $q.iconSet.datetime.today,\n            flat: true,\n            size: 'sm',\n            round: true,\n            tabindex: tabindex.value,\n            onClick: setToday\n          }) : null\n        ])\n      ])\n    }\n\n    function getNavigation ({ label, type, key, dir, goTo, boundaries, cls }) {\n      return [\n        h('div', {\n          class: 'row items-center q-date__arrow'\n        }, [\n          h(QBtn, {\n            round: true,\n            dense: true,\n            size: 'sm',\n            flat: true,\n            icon: dateArrow.value[ 0 ],\n            tabindex: tabindex.value,\n            disable: boundaries.prev === false,\n            ...getCache('go-#' + type, { onClick () { goTo(-1) } })\n          })\n        ]),\n\n        h('div', {\n          class: 'relative-position overflow-hidden flex flex-center' + cls\n        }, [\n          h(Transition, {\n            name: 'q-transition--jump-' + dir\n          }, () => h('div', { key }, [\n            h(QBtn, {\n              flat: true,\n              dense: true,\n              noCaps: true,\n              label,\n              tabindex: tabindex.value,\n              ...getCache('view#' + type, { onClick: () => { view.value = type } })\n            })\n          ]))\n        ]),\n\n        h('div', {\n          class: 'row items-center q-date__arrow'\n        }, [\n          h(QBtn, {\n            round: true,\n            dense: true,\n            size: 'sm',\n            flat: true,\n            icon: dateArrow.value[ 1 ],\n            tabindex: tabindex.value,\n            disable: boundaries.next === false,\n            ...getCache('go+#' + type, { onClick () { goTo(1) } })\n          })\n        ])\n      ]\n    }\n\n    const renderViews = {\n      Calendar: () => ([\n        h('div', {\n          key: 'calendar-view',\n          class: 'q-date__view q-date__calendar'\n        }, [\n          h('div', {\n            class: 'q-date__navigation row items-center no-wrap'\n          }, getNavigation({\n            label: innerLocale.value.months[ viewModel.value.month - 1 ],\n            type: 'Months',\n            key: viewModel.value.month,\n            dir: monthDirection.value,\n            goTo: goToMonth,\n            boundaries: navBoundaries.value.month,\n            cls: ' col'\n          }).concat(getNavigation({\n            label: viewModel.value.year,\n            type: 'Years',\n            key: viewModel.value.year,\n            dir: yearDirection.value,\n            goTo: goToYear,\n            boundaries: navBoundaries.value.year,\n            cls: ''\n          }))),\n\n          h('div', {\n            class: 'q-date__calendar-weekdays row items-center no-wrap'\n          }, daysOfWeek.value.map(day => h('div', { class: 'q-date__calendar-item' }, [ h('div', day) ]))),\n\n          h('div', {\n            class: 'q-date__calendar-days-container relative-position overflow-hidden'\n          }, [\n            h(Transition, {\n              name: 'q-transition--slide-' + monthDirection.value\n            }, () => h('div', {\n              key: viewMonthHash.value,\n              class: 'q-date__calendar-days fit'\n            }, days.value.map(day => h('div', { class: day.classes }, [\n              day.in === true\n                ? h(\n                  QBtn, {\n                    class: day.today === true ? 'q-date__today' : '',\n                    dense: true,\n                    flat: day.flat,\n                    unelevated: day.unelevated,\n                    color: day.color,\n                    textColor: day.textColor,\n                    label: day.i,\n                    tabindex: tabindex.value,\n                    ...getCache('day#' + day.i, {\n                      onClick: () => { onDayClick(day.i) },\n                      onMouseover: () => { onDayMouseover(day.i) }\n                    })\n                  },\n                  day.event !== false\n                    ? () => h('div', { class: 'q-date__event bg-' + day.event })\n                    : null\n                )\n                : h('div', '' + day.i)\n            ]))))\n          ])\n        ])\n      ]),\n\n      Months () {\n        const currentYear = viewModel.value.year === today.value.year\n        const isDisabled = month => {\n          return (\n            (minNav.value !== null && viewModel.value.year === minNav.value.year && minNav.value.month > month)\n            || (maxNav.value !== null && viewModel.value.year === maxNav.value.year && maxNav.value.month < month)\n          )\n        }\n\n        const content = innerLocale.value.monthsShort.map((month, i) => {\n          const active = viewModel.value.month === i + 1\n\n          return h('div', {\n            class: 'q-date__months-item flex flex-center'\n          }, [\n            h(QBtn, {\n              class: currentYear === true && today.value.month === i + 1 ? 'q-date__today' : null,\n              flat: active !== true,\n              label: month,\n              unelevated: active,\n              color: active === true ? computedColor.value : null,\n              textColor: active === true ? computedTextColor.value : null,\n              tabindex: tabindex.value,\n              disable: isDisabled(i + 1),\n              ...getCache('month#' + i, { onClick: () => { setMonth(i + 1) } })\n            })\n          ])\n        })\n\n        props.yearsInMonthView === true && content.unshift(\n          h('div', { class: 'row no-wrap full-width' }, [\n            getNavigation({\n              label: viewModel.value.year,\n              type: 'Years',\n              key: viewModel.value.year,\n              dir: yearDirection.value,\n              goTo: goToYear,\n              boundaries: navBoundaries.value.year,\n              cls: ' col'\n            })\n          ])\n        )\n\n        return h('div', {\n          key: 'months-view',\n          class: 'q-date__view q-date__months flex flex-center'\n        }, content)\n      },\n\n      Years () {\n        const\n          start = startYear.value,\n          stop = start + yearsInterval,\n          years = []\n\n        const isDisabled = year => {\n          return (\n            (minNav.value !== null && minNav.value.year > year)\n            || (maxNav.value !== null && maxNav.value.year < year)\n          )\n        }\n\n        for (let i = start; i <= stop; i++) {\n          const active = viewModel.value.year === i\n\n          years.push(\n            h('div', {\n              class: 'q-date__years-item flex flex-center'\n            }, [\n              h(QBtn, {\n                key: 'yr' + i,\n                class: today.value.year === i ? 'q-date__today' : null,\n                flat: !active,\n                label: i,\n                dense: true,\n                unelevated: active,\n                color: active === true ? computedColor.value : null,\n                textColor: active === true ? computedTextColor.value : null,\n                tabindex: tabindex.value,\n                disable: isDisabled(i),\n                ...getCache('yr#' + i, { onClick: () => { setYear(i) } })\n              })\n            ])\n          )\n        }\n\n        return h('div', {\n          class: 'q-date__view q-date__years flex flex-center'\n        }, [\n          h('div', {\n            class: 'col-auto'\n          }, [\n            h(QBtn, {\n              round: true,\n              dense: true,\n              flat: true,\n              icon: dateArrow.value[ 0 ],\n              tabindex: tabindex.value,\n              disable: isDisabled(start),\n              ...getCache('y-', { onClick: () => { startYear.value -= yearsInterval } })\n            })\n          ]),\n\n          h('div', {\n            class: 'q-date__years-content col self-stretch row items-center'\n          }, years),\n\n          h('div', {\n            class: 'col-auto'\n          }, [\n            h(QBtn, {\n              round: true,\n              dense: true,\n              flat: true,\n              icon: dateArrow.value[ 1 ],\n              tabindex: tabindex.value,\n              disable: isDisabled(stop),\n              ...getCache('y+', { onClick: () => { startYear.value += yearsInterval } })\n            })\n          ])\n        ])\n      }\n    }\n\n    function onDayClick (dayIndex) {\n      const day = { ...viewModel.value, day: dayIndex }\n\n      if (props.range === false) {\n        toggleDate(day, viewMonthHash.value)\n        return\n      }\n\n      if (editRange.value === null) {\n        const dayProps = days.value.find(day => day.fill !== true && day.i === dayIndex)\n\n        if (props.noUnset !== true && dayProps.range !== void 0) {\n          removeFromModel({ target: day, from: dayProps.range.from, to: dayProps.range.to })\n          return\n        }\n\n        if (dayProps.selected === true) {\n          removeFromModel(day)\n          return\n        }\n\n        const initHash = getDayHash(day)\n\n        editRange.value = {\n          init: day,\n          initHash,\n          final: day,\n          finalHash: initHash\n        }\n\n        emit('rangeStart', getShortDate(day))\n      }\n      else {\n        const\n          initHash = editRange.value.initHash,\n          finalHash = getDayHash(day),\n          payload = initHash <= finalHash\n            ? { from: editRange.value.init, to: day }\n            : { from: day, to: editRange.value.init }\n\n        editRange.value = null\n        addToModel(initHash === finalHash ? day : { target: day, ...payload })\n\n        emit('rangeEnd', {\n          from: getShortDate(payload.from),\n          to: getShortDate(payload.to)\n        })\n      }\n    }\n\n    function onDayMouseover (dayIndex) {\n      if (editRange.value !== null) {\n        const final = { ...viewModel.value, day: dayIndex }\n\n        Object.assign(editRange.value, {\n          final,\n          finalHash: getDayHash(final)\n        })\n      }\n    }\n\n    // expose public methods\n    Object.assign(proxy, {\n      setToday, setView, offsetCalendar, setCalendarTo, setEditingRange\n    })\n\n    return () => {\n      const content = [\n        h('div', {\n          class: 'q-date__content col relative-position'\n        }, [\n          h(Transition, {\n            name: 'q-transition--fade'\n          }, renderViews[ view.value ])\n        ])\n      ]\n\n      const def = hSlot(slots.default)\n      def !== void 0 && content.push(\n        h('div', { class: 'q-date__actions' }, def)\n      )\n\n      if (props.name !== void 0 && props.disable !== true) {\n        injectFormInput(content, 'push')\n      }\n\n      return h('div', {\n        class: classes.value,\n        ...attributes.value\n      }, [\n        getHeader(),\n\n        h('div', {\n          ref: blurTargetRef,\n          class: 'q-date__main col column',\n          tabindex: -1\n        }, content)\n      ])\n    }\n  }\n})\n",
      "start": 1703982896203,
      "end": 1703982896289,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1703982896289,
      "end": 1703982896289,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703982896289,
      "end": 1703982896290,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703982896290,
      "end": 1703982896290,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1703982896290,
      "end": 1703982896290,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703982896290,
      "end": 1703982896290,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703982896290,
      "end": 1703982896290,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1703982896290,
      "end": 1703982896293,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703982896293,
      "end": 1703982896293,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703982896293,
      "end": 1703982896293,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1703982896293,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "quasar:directive",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1703982896294,
      "end": 1703982896294,
      "order": "normal"
    }
  ]
}
